<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
<link rel="stylesheet" href="style.css">
   <link rel="stylesheet" href="reset.css">
	
</head>

<body>
    <section id="arrinfo">
     <div id="cord">
		X0:Y0
    </div>
    <div id="cell">
		X0:Y0
    </div>
 <div id="cord2">
		X0:Y0
    </div>
 <div id="cord3">
		X0:Y0
    </div>
	</section>
	<canvas id="canvas"></canvas>
    <script type="text/javascript">
    let gId = (id) => {
        return document.getElementById(id);
    };
    arr=[];
    const canvas = gId('canvas');
    const ctx = canvas.getContext('2d');
    let width = window.innerWidth,
	    height = window.innerHeight;
    let grid =32, gridX =Math.floor(width/grid),gridY=Math.floor(height/grid);     
    canvas.width = gridX*grid;
    canvas.height = gridY*grid;
    canvas.style.backgroundColor = "#D0D0D0";
    let cordX=10*grid;
    let cordY=5*grid;


	

	
let mzcolor =()=>{
	for(i=0;i<gridX;i++){
		for(j=0;j<gridY;j++){
			let arch=arr[i][j];
			if(arch==0){
			ctx.strokeStyle = "white";
			ctx.strokeRect(i*grid,j*grid,grid,grid);
			}		
			else if(arch==1){
			ctx.fillStyle = "red";
			ctx.fillRect(i*grid+2,j*grid+2,grid-4,grid-4);
			}	
			else if(arch==2){
			ctx.fillStyle = "black";
			ctx.fillRect(i*grid,j*grid,grid,grid);
			}	
		}
	}
};
	
let rect=(x,y,w,h,color)=>{
	ctx.fillStyle=color;
	ctx.fillRect(x,y,w,h);
};

let text =(x,y,cell,col)=>{
	ctx.font = "20px serif";
    ctx.fillStyle=col;
    ctx.textBaseline = "bottom";
    ctx.textAlign = "left";
    ctx.fillText(cell, x, y);
};  
    

    let Unit =function(){
        this.tileFrom =[1,1];
		this.tileTo   =[1,1];
		this.dimensions=[grid,grid];
		this.position  =[Math.floor(gridX/2),Math.floor((gridY/2)*grid)];
		this.x=10*grid;
        this.y=2*grid;
        this.posX=2;
		this.posY=2;
		
		this.speed=4;
        this.xSpeed=0;
        this.ySpeed=0;
        this.sizeW=32;
        this.sizeH=32;
    };

    Unit.prototype.draw=function(){
		rect(this.x,this.y,this.sizeW,this.sizeH,"blue")
		player.move();
	};
    
	/*Unit.prototype.move=function(){
        
		if(this.x!==cordX || this.y!==cordY){
		   if(this.x>cordX && arr[this.posX-1][this.posY]!==2){
		       this.xSpeed=this.speed
			   this.x-=this.xSpeed;
		   }
		    if(this.y>cordY && arr[this.posX][this.posY-1]!==2){
				this.ySpeed=this.speed
				this.y-=this.ySpeed;
		   }
		    if(this.x<cordX && arr[this.posX+1][this.posY]!==2){
		       this.xSpeed=this.speed
			   this.x+=this.xSpeed;
		       
		   }
		   if(this.y<cordY && arr[this.posX][this.posY+1]!==2){
				this.ySpeed=this.speed;
				this.y+=this.ySpeed;
		        
		   }
			
		}*/
		
   Unit.prototype.move=function(){
        if(this.x!==cordX || this.y!==cordY){
		   let tarcor=(cordX/grid)+(cordY/grid);
	       let thecord=(this.x/grid)+(this.y/grid);
		   let tcorX=this.x/grid, tkorY=this.y/grid;
		   
		   let north=arr[tcorX][tkorY-1];
	       let south=arr[tcorX][tkorY+1];
	       let west=arr[tcorX+1][tkorY];
	       let ost=arr[tcorX-1][tkorY];
		   
		   if(thecord<tarcor){
		       let n=[tcorX,(tkorY-1)],
		       	   s=[tcorX,(tkorY+1)],
 				   w=[(tcorX+1),tkorY],
                   o=[(tcorX-1),tkorY];
		      console.log('n'+ n, 's' + s,'w' + w, 'o' + o);
           
           }
           if(thecord<tarcor){
		      

		       
			   
		   }


			
		}
   
   
   this.posX=Math.floor(this.x/grid);
   this.posY=Math.floor(this.y/grid); 
   console.log(this.posX,this.posY)
   };
	
	let player= new Unit();


canvas.oncontextmenu = function (e){
draw(e);
 return false;
};	
	
function draw(e) {
  
   var dotx = Math.round(e.clientX - canvas.offsetLeft);
    var doty = Math.round(e.clientY - canvas.offsetTop);
 
  var xcell = Math.floor(dotx / (grid));
  var ycell = Math.floor(doty / (grid));
  ctx.fillRect((xcell) * grid, (ycell) * grid, grid, grid);
  arr[xcell][ycell]=2;
  
}
	
canvas.onclick=(e)=>{
  let dotx = Math.round(e.clientX - canvas.offsetLeft);
  let doty = Math.round(e.clientY - canvas.offsetTop);
  let xcell = Math.floor(dotx / (grid));
  let ycell = Math.floor(doty / (grid));
  let chec = arr[xcell][ycell];
  cordX=xcell*grid,cordY=ycell*grid; 
  cord.innerHTML ='X' + cordX +':' + 'Y'+ cordY;
  cell.innerHTML ='X' + player.x +':' + 'Y'+ player.y;
  mv();
  /*rect((xcell*grid)+2,(ycell*grid)+2,grid-4,grid-4,"red")
  arr[xcell][ycell]=1;*/
};
function mv(){
        if(this.x!==cordX || this.y!==cordY){
		   let tarcor=(cordX/grid)+(cordY/grid);
	       let thecord=(player.x/grid)+(player.y/grid);
		   let rast=heuristic(player)
		   cord2.innerHTML ='From' + thecord +'->' + 'To'+ tarcor;
		   cord3.innerHTML =rast;
		   let tcorX=player.x/grid, tkorY=player.y/grid;
		   if(thecord<tarcor){
		       let n= tcorX+(tkorY-1),
		       	   s= tcorX+(tkorY+1),
 				   w= (tcorX+1)+tkorY,
                   o= (tcorX-1)+tkorY;
		        
			 //cord3.innerHTML ='n'+ n + 's' + s +'w' + w + 'o' + o;
           
           }
           if(thecord<tarcor){
		      

		       
			   
		   }


			
		}}
function heuristic(pl) {
    // This is the Manhattan distance
    var d1 = Math.abs ((pl.x/grid) - (cordX/grid));
    var d2 = Math.abs ((pl.y/grid) - (cordY/grid));
    return d1 + d2;
	
	/*var d1 = Math.abs (pos1.x - pos0.x);
    var d2 = Math.abs (pos1.y - pos0.y);
    return d1 + d2;*/
  };
function  neighbors (ar, node) {//neighbors (arr, player)
    var ret = [];
    var x = node.x/grid;
    var y = node.y/grid;
    console.log(x,y)
    if(ar[x-1][y]==0) {
      ret.push(ar[x-1][y]);
    }
    if(ar[x+1][y]==0) {
      ret.push(ar[x+1][y]);
    }
    if(ar[x][y-1]==0) {
      ret.push(ar[x][y-1]);
    }
    if(ar[x][y+1]==0) {
      ret.push(ar[x][y+1]);
    }
    console.log(ret)
	return ret;
};

function init(grid) {//init(arr)
    for(var x = 0; x < grid.length; x++) {
      for(var y = 0; y < grid[x].length; y++) {
        grid[x][y].f =0 ;
        grid[x][y].g =0 ;
        grid[x][y].h =0 ;
        grid[x][y].debug = "";
        grid[x][y].parent = null;
      }  
    }
  };

 /*function search(grid, start, end) {
    astar.init(grid);
 
    var openList   = [];
    var closedList = [];
    openList.push(start);
 
    while(openList.length > 0) {
 
      // Grab the lowest f(x) to process next
      var lowInd = ;
      for(var i=; i<openList.length; i++) {
        if(openList[i].f < openList[lowInd].f) { lowInd = i; }
      }
      var currentNode = openList[lowInd];
 
      // End case -- result has been found, return the traced path
      if(currentNode.pos == end.pos) {
        var curr = currentNode;
        var ret = [];
        while(curr.parent) {
          ret.push(curr);
          curr = curr.parent;
        }
        return ret.reverse();
      }
 
      // Normal case -- move currentNode from open to closed, process each of its neighbors
      openList.removeGraphNode(currentNode);
      closedList.push(currentNode);
      var neighbors = astar.neighbors(grid, currentNode);
 
      for(var i=; i<neighbors.length;i++) {
        var neighbor = neighbors[i];
        if(closedList.findGraphNode(neighbor) || neighbor.isWall()) {
          // not a valid node to process, skip to next neighbor
          continue;
        }
 
        // g score is the shortest distance from start to current node, we need to check if
        //   the path we have arrived at this neighbor is the shortest one we have seen yet
        var gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor
        var gScoreIsBest = false;
 
 
        if(!openList.findGraphNode(neighbor)) {
          // This the the first time we have arrived at this node, it must be the best
          // Also, we need to take the h (heuristic) score since we haven't done so yet
 
          gScoreIsBest = true;
          neighbor.h = astar.heuristic(neighbor.pos, end.pos);
          openList.push(neighbor);
        }
        else if(gScore < neighbor.g) {
          // We have already seen the node, but last time it had a worse g (distance from start)
          gScoreIsBest = true;
        }
 
        if(gScoreIsBest) {
          // Found an optimal (so far) path to this node.   Store info on how we got here and
          //  just how good it really is...
          neighbor.parent = currentNode;
          neighbor.g = gScore;
          neighbor.f = neighbor.g + neighbor.h;
          neighbor.debug = "F: " + neighbor.f + "<br />G: " + neighbor.g + "<br />H: " + neighbor.h;
        }
      }
    }
 
    // No result was found -- empty array signifies failure to find path
    return [];
  },*/
	

	
	(()=>{
    for(i=0;i<gridX;i++){
		arr[i]=[]
		for(j=0;j<gridY;j++){
			arr[i][j]=0;
		}
	}
mzcolor();
	player.draw();
	})();
	
	
	
	
	
	
	


    </script>
</body>

</html>